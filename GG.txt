Init:

okres_probkowania := 0.1;
stala_czasowa := 10.0;
K_p_proces := 25.0;
u_k := 1.5; //wstepna wartosc sterowania

//Inicjalizacja MODBUS
Pomiar_MODBUS := 0;
Zapis_MODBUS := 0;

MOV(TRUE, K15, Slave_adres);
MOV(TRUE, K4, Function_code); //4-pomiar, 3-sterowanie
MOV(TRUE, K0, Modbus_adres); //zaczynamy liczyc od 0
MOV(TRUE, K7, Device_count); //7 pomiarow, 6 sterowan



//Ustawienie poczatkowe wyjsc procesu
ZRST(TRUE, D110, D120);

D114 := 250;
D115 := 300;
D110 := 500;
D111 := 500;

T_p := 4.0;

K_1 := 3.0;
Ti_1 := 55.0;
Td_1 := 0.1;

K_2 := 3.0;
Ti_2 := 55.0;
Td_2 := 0.1;

r0_1 := K_1 * (1 + 0.5 * (T_p / Ti_1) + Td_1 / T_p);
r1_1 := K_1 * (0.5 * (T_p / Ti_1) - 2 * Td_1 / T_p - 1);
r2_1 := K_1 * Td_1 / T_p;

r0_2 := K_2 * (1 + 0.5 * (T_p / Ti_2) + Td_2 / T_p);
r1_2 := K_2 * (0.5 * (T_p / Ti_2) - 2 * Td_2 / T_p - 1);
r2_2 := K_2 * Td_2 / T_p;

yzad_1 := 35.0;
yzad_2 := 35.0;

state := 0;
count := 0;

SD414 := 2; //timer 2n, ktorego odliczenie odczytujemy z SM414 // ustawiony okres 4 sekundy

Main:

//Opoznienie po wlaczeniu sterownika - zezwolenie komunikacji modbus ze stanowiskiem
OUT_T(TRUE,TC0,K20);

SET(LDP(TRUE,TS0),Pozwolenie_pomiar_MODBUS);
SET(LDP(TRUE,TS0),Pozwolenie_zapis_MODBUS);

//float(real) przykladowe operacje
licznik := 0;
liczba1 := 123.4;
wynik   := 0.0;

//petla FOR
FOR  licznik := 1  TO  1000  BY  1  DO
	 wynik := liczba1 * licbza2;
END_FOR;

EI(TRUE); //przerwania zalaczone

TIM_MAIN(PT:= T#5s);


/*
CASE  Stan_MAIN  OF
	0:
		u_k := 10.0;
		TIM_MAIN.IN := 1;
		Stan_MAIN := 1;
	
	1:	
		IF TIM_MAIN.Q THEN
			u_k := 3.0;
			TIM_MAIN.IN := 0;
			Stan_MAIN := 2;		
		END_IF;
	
	2:
		Stan_MAIN := 3;	
			
	3:
		IF NOT TIM_MAIN.Q THEN
			TIM_MAIN.IN := 1;
			Stan_MAIN := 4;
		END_IF;
	
	4:
		IF TIM_MAIN.Q THEN
			u_k := 10.0;
			TIM_MAIN.IN := 0;
			Stan_MAIN := 5;		
		END_IF;		

	5:
		Stan_MAIN := 0;		
		
END_CASE;
*/

Modbus:

ET(Pozwolenie_pomiar_MODBUS AND LDP(TRUE,SM413),Pomiar_MODBUS);
IF(Pomiar_MODBUS) THEN
	Function_code := 4;
	Device_count := 7;
	ADPRW( Pomiar_MODBUS AND NOT Zapis_MODBUS, Slave_adres , Function_code , Modbus_adres, Device_count , D100, M100);
	IF(M101) THEN
		RST(TRUE, Pomiar_MODBUS);
		RST(TRUE, M101);
		RST(TRUE, M100);
	END_IF;
END_IF;


SET(Pozwolenie_zapis_MODBUS AND LDF(TRUE,SM413),Zapis_MODBUS);
IF(Zapis_MODBUS) THEN
	Function_code := 16;
	Device_count := 6;
	ADPRW( Zapis_MODBUS AND NOT Pomiar_MODBUS, Slave_adres , Function_code , Modbus_adres, Device_count , D110, M110);
	IF(M111) THEN
		RST(TRUE, Zapis_MODBUS);
		RST(TRUE, M111);
		RST(TRUE, M110);
	END_IF;
END_IF;


SocketComm:

// Sprawdzenie otwartego polaczenia
SP_SOCCINF( SD10680.0 , 'U0' , K1 , Control_data_SOCCINF , Conn_info_SOCCINF );


OUT(SD10680.0 AND SM412, Y17);

//IF AUTO_SEND AND LDP(TRUE, SM414) THEN
IF AUTO_SEND AND LDP(TRUE, SM412) THEN

//Generacja tesktu do wyslania przez socket communication

	text_temp := 'Y1=';

	text_temp := CONCAT(text_temp,REAL_TO_STRING(y_1));

	text_temp := CONCAT(text_temp,';Y2=');	
	
	text_temp := CONCAT(text_temp,REAL_TO_STRING(y_2));	
	
	text_temp := CONCAT(text_temp,';U1=');
	
	text_temp := CONCAT(text_temp,REAL_TO_STRING(u_1));	

	text_temp := CONCAT(text_temp,';U2=');
		
	text_temp := CONCAT(text_temp,REAL_TO_STRING(u_2));	
	
	text_temp := CONCAT(text_temp,';Yz1=');
	
	text_temp := CONCAT(text_temp,REAL_TO_STRING(yzad_1));	

	text_temp := CONCAT(text_temp,';Yz2=');
		
	text_temp := CONCAT(text_temp,REAL_TO_STRING(yzad_2));	

	text_temp := CONCAT(text_temp,';$L');	

	//Dlugosc tekstu
	text_length := INT_TO_WORD( LEN(text_temp) );
	
	Trigger_Send := 1;
	
END_IF;

IF SD10680.0 THEN
	AUTO_SEND := TRUE;
END_IF;

// jezeli komunikacja zostala zerwana skasuj flagi wysylania
IF LDF(TRUE, SD10680.0) THEN
	AUTO_SEND := FALSE;
	Trigger_Send := FALSE;
END_IF;

SP_SOCSND(AUTO_SEND AND LDP(TRUE, Trigger_Send) AND SD10680.0 , 'U0' , K1 , Control_data_SOCSND , text_length , M300 );

IF M300 AND NOT M301 THEN
	Trigger_Send := 0;
END_IF;



Regulator:
y_1 := INT_TO_REAL(D100) / 100.0;
y_2 := INT_TO_REAL(D102) / 100.0;
u_1 := INT_TO_REAL(D114) / 10.0;
u_2 := INT_TO_REAL(D115) / 10.0;

e_1 := yzad_1 - y_1;
e_2 := yzad_2 - y_2;

u_1 := u_1_k_1 + r0_1 * e_1 + r1_1 * e_1_k_1 + r2_1 * e_1_k_1;
u_2 := u_2_k_1 + r0_2 * e_2 + r1_2 * e_2_k_1 + r2_2 * e_2_k_1;

IF u_1 > 100.0 THEN
	u_1 := 100.0;
END_IF;

IF u_2 > 100.0 THEN
	u_2 := 100.0;
END_IF;

IF u_1 < 0.0 THEN
	u_1 := 0.0;
END_IF;

IF u_2 < 0.0 THEN
	u_2 := 0.0;
END_IF;

u_1_k_1 := u_1;
u_2_k_1 := u_2;
e_1_k_2 := e_1_k_1;
e_1_k_1 := e_1;
e_2_k_2 := e_2_k_1;
e_2_k_1 := e_2;


IF y_1 > 250.0 OR y_2 > 250.0 THEN
	u_1 := 0.0;
	u_2 := 0.0;
END_IF;

D114 := REAL_TO_INT(u_1 * 10.0);
D115 := REAL_TO_INT(u_2 * 10.0);






// Automat stanowy
count := count + 1;
IF count > 64 THEN
	count := 0;
	IF state = 3 THEN
		state := 4;
		yzad_1 := 35.0;
		yzad_2 := 35.0;
	END_IF;
	IF state = 2 THEN
		state := 3;
		yzad_1 := 35.0;
		yzad_2 := 45.0;
	END_IF;
	IF state = 1 THEN
		state := 2;
		yzad_1 := 45.0;
		yzad_2 := 45.0;
	END_IF;
	IF state = 0 THEN
		state := 1;
		yzad_1 := 45.0;
		yzad_2 := 35.0;
	END_IF;
	IF state = 4 THEN
		state := 0;
	END_IF;
END_IF;

